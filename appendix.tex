\chapter{Codes and Implementations}
\label{appendix:codes}

Listed in this section are the core codes used in the study. Complete source codes are available at my private GitHub repository. Access can be requested via email at \url{kvdomingo@up.edu.ph}.

\singlespacing
\lstset{
	basicstyle=\footnotesize\ttfamily,
	commentstyle=\itshape\color{green!50!black},
	keywordstyle=\bfseries\color{blue},
	stringstyle=\color{red!70!black},
	numberstyle=\footnotesize\ttfamily,
	numbersep=15pt,
	tabsize=4,
	frame=lines,
	language=Python,
	numbers=left,
}
\lstset{morekeywords={as, True, False}}


\lstset{
	label={code:1d-test},
	caption={Compressive sensing of 1D test sinusoids.}
}
\begin{lstlisting}
import numpy as np
import numpy.random as rand
import scipy.fftpack as fft

# load recording
signal = np.loadtxt("piano.txt").astype("float32")

# define parameters
samprate = 44.1e3
duration = 1/8
N = int(duration*samprate)
M = 300
t = np.linspace(0, duration, N)

# extract short portion of recording
sig_start = 40000
x = signal[sig_start:sig_start + N]

# simulate compressive measurements
yi = rand.randint(0, N, M)
yi = np.sort(yi)
y = x[yi]

# L1 optimization using CVX ECOS
import cvxpy as cvx
xhat_cvx = cvx.Variable(N)
objective = cvx.Minimize(cvx.Norm(xhat_cvx, 1))
constraints = [A*xhat_cvx == y]
prob = cvx.Problem(objective, constraints)
result = prob.solve(verbose=True, solver="ECOS")
x_cvx = np.array(xhat_cvx.value)
x_cvx = np.squeeze(x_cvx)
x_cvx = fft.dct(x_cvx, norm="ortho", axis=0)

# L1-regularized L2 optimization using LASSO
from sklearn.linear_model import Lasso, LassoCV
lasso = LassoCV(cv=10, random_state=0, verbose=True, n_jobs=-1)
lasso.fit(A, y)
x_lasso = fft.idct(lasso.coef_)
\end{lstlisting}


\lstset{
	label={code:sl0},
	caption={Implementation of GPU-accelerated SL0, translated from original MATLAB version.}
}
\begin{lstlisting}
import numpy as np
import numpy.random as rand
import tensorflow as tf
import scipy.fftpack as fft

# define L0 norm estimator function
def Fsigma(x_i, sigma):
	x = tf.abs(x_i)
	return x_i * tf.exp(-x**2/(2*sigma**2))

def SL0(A, b, Fsigma=Fsigma, sigma_min=1e-12, mu_0=2, L=3, sdf=0.5):
	A = tf.convert_to_tensor(A, dtype=tf.float32)
	b = tf.convert_to_tensor(b, dtype=tf.float32)
	A_plus = tf.linalg.pinv(A)
	x = tf.linalg.matmul(A_plus, b)
	sigma = 2 * np.max(np.abs(x.numpy()))
	while sigma > sigma_min:
		for i in range(L):
			delta = Fsigma(x, sigma)
			x -= mu_0 * delta
			x -= tf.linalg.matmul(A_plus, tf.linalg.matmul(A, x) - b)
		sigma *= sdf
	return x.numpy()
\end{lstlisting}

\clearpage

\lstset{
	label={code:sl0-encrypt},
	caption={Image with multiple sinusoids.}
}
\begin{lstlisting}
import numpy as np
import numpy.random as rand
import scipy.fftpack as fft
import cv2 as cv

X_orig = cv.resize(
	cv.imread("escher_relativity.jpg", 0),
	(1600, 976)
)
ny, nx = X_orig.shape
sec = 16
k = int(X_orig.size * 0.5)
ri = rand.choice(X_orig.size, k, replace=False)
Xm = 255 * np.ones(X_orig.shape)
Xm.T.flat[ri] = X_orig.T.flat[ri]

n = np.arange(sec)
slices = np.zeros((sec, sec), object)
recover = np.zeros((sec, sec), object)
for j in n:
	for i in n:
		slices[j,i] = X_orig[
			ny//sec*j:ny//sec*(j+1),
			nx//sec*i:nx//sec*(i+1)
		]
		
ny, nx = slices[j, i].shape
ex = 0.5
k = np.round(nx * ny * ex).astype(int)
ri = rand.choice(nx * ny, k, replace=False)
A = np.kron(
	fft.idct(np.identity(nx), norm='ortho', axis=0),
	fft.idct(np.identity(ny), norm='ortho', axis=0)
)
A = A[ri,:]

for j in trange(len(slices)):
	for i in trange(len(slices)):
		b = slices[j,i].T.flat[ri]
		vx = cvx.Variable(nx * ny)
		objective = cvx.Minimize(cvx.norm(vx, 1))
		constraints = [A*vx == b]
		prob = cvx.Problem(objective, constraints)
		result = prob.solve()
		Xat2 = np.array(vx.value)
		Xat2 = np.squeeze(Xat2)
		
		Xat = Xat2.reshape(nx, ny).T
		Xa = idct2(Xat)
		recover[j,i] = Xa
		
recovery = np.zeros(len(recover), object)
for i in range(len(recover)):
	recovery[i] = np.concatenate(recover[i,:], axis=1)
recovery = recovery.T
recovery = np.concatenate(recovery[:], axis=0)
\end{lstlisting}


\lstset{
	label={code:sl0-encrypt},
	caption={Simultaneous compression-encryption with SL0.}
}
\begin{lstlisting}
import numpy as np
import numpy.random as rand
import scipy.fftpack as fft
import cv2 as cv

def encrypt(filename, compression, key1, key2, key3):
	if isinstance(filename, str):
		X = cv.imread(filename, 0)
	if isinstance(filename, np.ndarray):
		X = filename.copy()
	N = len(X)
	M = int(compression * N)
	
	lamda1 = [key1]
	lamda2 = [key2]
	for i in range(1, 2*N):
		lamda1.append(key3*lamda1[i-1]*(1 - lamda1[i-1]))
		lamda2.append(key3*lamda2[i-1]*(1 - lamda2[i-1]))

	s1 = np.array(lamda1[N:])
	s2 = np.array(lamda2[N:])
	n = np.arange(N)
	sorty1 = np.array([s1, n]).T
	sorty2 = np.array([s2, n]).T
	sorty1 = sorty1[sorty1[:, 0].argsort()]
	sorty2 = sorty2[sorty2[:, 0].argsort()]
	l1 = sorty1.T[1].astype(np.uint8)
	l2 = sorty2.T[1].astype(np.uint8)
	
	H = np.linalg.hadamard(2**(np.round(np.log2(N)).astype(int)))
	Phi1 = H[l1[:M], :N]
	Phi2 = H[l2[:M], :N]
	
	Psi = fft.dct(np.identity(N))
	beta1 = Phi1.dot(Psi.T.dot(X))
	beta = Psi.T.dot(X.T.dot(Psi))
	beta2 = Psi.T.dot(beta1.T)
	Y = Phi2.dot(beta.dot(Phi1.T))
	return (Y, compression)
	
def decrypt(signal_in, decompress, key1, key2, key3):
	M = len(signal_in)
	N = int(M/decompress)
	lamda1 = [key1]
	lamda2 = [key2]
	for i in range(1, 2*N):
		lamda1.append(key3*lamda1[i-1]*(1 - lamda1[i-1]))
		lamda2.append(key3*lamda2[i-1]*(1 - lamda2[i-1]))
		
	s1 = np.array(lamda1[N:])
	s2 = np.array(lamda2[N:])
	n = np.arange(N)
	sorty1 = np.array([s1, n]).T
	sorty2 = np.array([s2, n]).T
	sorty1 = sorty1[sorty1[:, 0].argsort()]
	sorty2 = sorty2[sorty2[:, 0].argsort()]
	l1 = sorty1.T[1].astype(np.uint8)
	l2 = sorty2.T[1].astype(np.uint8)
	
	H = np.linalg.hadamard(2**(np.round(np.log2(N)).astype(int)))
	Phi1 = H[l1[:M], :N]
	Phi2 = H[l2[:M], :N]
	
	y1 = SL0(Phi2, signal_in)
	y2 = SL0(Phi1, y1.T)
	Y = idct2(ydir2)
	return (Y, decompress)
\end{lstlisting}


\lstset{
	label={code:1dcs},
	caption={Reading from an audio file and performing CS.}
}
\begin{lstlisting}
import numpy as np
import numpy.random as rand
import scipy.fftpack as fft
import scipy.io.wavfile as wav
import IPython.display as disp

class compsenseFromFile:
	def __init__(self, filename, downsample=False, downrate=None):
		self.rate, self.data = wav.read(filename)
		self.filename = filename
		self.name = filename[:-4]
		if len(self.data.shape) > 1 and self.data.shape[1] > 1:
			self.data = self.data.mean(axis=1)
		self.N = len(self.data)
		self.dur = self.N/self.rate
		self.t = np.linspace(0, self.dur, self.N)
		self.coef = fft.fft(self.data)
		self.coefshift = fft.fftshift(self.coef)
		if downsample:
			self.downrate = downrate
			self.Nd = int(downrate * self.dur)
			nd = np.round(np.linspace(0, self.N-1, self.Nd)).astype(int)
			self.data = self.data[nd]
			self.t = self.t[nd]
			self.coef = fft.fft(self.data)
			self.coefshift = fft.fftshift(self.coef)
			self.rate = downrate
		else:
			self.Nd = self.N
			self.t = np.linspace(0, self.dur, self.Nd)
			
	def getDominantFrequency(coef, rate):
		return np.argmax(abs(coef))/len(coef)*rate
	
	def sampleCompressive(self, mode, rate):
		self.subrate = rate
		self.M = int(self.subrate*self.dur)
	
		if mode == "random":
			m = np.sort(rd.randint(0, self.Nd, self.M))
			elif mode == "subnyquist":
			m = np.round(np.linspace(0, self.Nd-1, self.M)).astype(int)
		else:
			raise ValueError("Specified mode is invalid")
		
		self.y = self.data[m]
		self.tm = self.t[m]
		self.compressedCoef = fft.fft(self.y)
		self.compressedCoefShift = fft.fftshift(self.compressedCoef)
		self.m = m

	def recovery(self, method, **method_kwargs):
		self.method = method
		d = fft.dct(np.identity(self.Nd))
		A = d[self.m]
		
		if method == "lasso":
			prob = skl.Lasso(**method_kwargs)
		elif method == "lassocv":
			prob = skl.LassoCV(**method_kwargs)
		elif method == "omp":
			prob = skl.OrthogonalMatchingPursuit(**method_kwargs)
		elif method == "sl0":
			prob = SL0(A, self.y)
			self.recoveredCoef = prob
			return
		else:
			raise ValueError("Specified method is invalid")
		
		prob.fit(A, self.y)
		self.recoveredCoef = prob.coef_
	
	def main(self, mode, rate, method, **method_kwargs):
		self.sampleCompressive(mode, rate)
		self.recovery(method, **method_kwargs)
\end{lstlisting}


\lstset{
	label={code:speech-cs},
	caption={Parsing speech from multiple sources and performing CS.}
}
\begin{lstlisting}
	class SpeechCS:
		def __init__(
			self,
			filename,
			rate=None,
			downsample=False,
			downrate=None
		):
			source_type = type(filename)
			if source_type == str:
				if filename.endswith(".wav"):
					self.data, self.rate = sf.read(filename)
				elif filename.endswith(".csv"):
					self.data = np.genfromtxt(filename, delimiter=",")
					if rate is not None:
						self.rate = rate
					else:
						self.rate = int(input("Enter sample rate: "))
				else:
					return "Unsupported file type"
			elif source_type == np.ndarray:
				self.data = filename
				if rate is not None:
					self.rate = rate
				else:
					self.rate = int(input("Enter sample rate: "))
			
			self.dur = self.data.size/self.rate
			self.name = filename[:-4]
			self.filename = filename
			
			if len(self.data.shape) > 1 and self.data.shape[1] > 1:
				self.data = self.data.mean(axis=1)
			
			if downsample:
				self.rate = downrate
				downsize = int(self.dur * downrate)
				down_idx = np.round(np.linspace(
					0,
					self.data.size-1,
					downsize
				)).astype(int)
				self.data = self.data[down_idx]
			
			self.t = np.linspace(0, self.dur, self.data.size)
		
		def sampleCompressive(
			self,
			comp_ratio,
			seglen,
			percent_overlap,
			window="hann"
		):
			hop_size = int(seglen * percent_overlap)
			starts = np.arange(
				0,
				self.data.size,
				seglen - hop_size,
				dtype=int
			)
			starts = starts[starts + seglen < self.data.size]
			w = sig.get_window(window, seglen + 1)[:-1]
			comp_size = int(seglen * comp_ratio)
			comp_rate = int(self.rate * comp_ratio)
			xhat = np.zeros_like(self.data, complex)
			wsum = np.zeros_like(xhat)
			rand_idx = np.zeros((len(starts), comp_size), int)
			for i in range(len(rand_idx)):
				rand_idx[i] = rd.choice(
					seglen,
					size=comp_size,
					replace=False
				)
			spars_basis = fft.dct(np.identity(seglen))
			for i,n in enumerate(starts):
				x = w * self.data[n : n + seglen]
				y = x[rand_idx[i]]
				A = spars_basis[rand_idx[i]]
				
				if i == 0:
					prob = skl.LassoCV(
						cv=10,
						random_state=0,
						n_jobs=3
					)
					prob.fit(A, y)
					alpha = prob.alpha_
				
				prob = skl.Lasso(alpha=alpha)
				with warnings.catch_warnings():
					warnings.simplefilter("ignore")
					prob.fit(A, y)
				
				xhat[n : n + seglen] += w * fft.idct(prob.coef_)
				wsum[n : n + seglen] += w**2
			
			self.seglen = seglen
			self.comp_ratio = comp_ratio
			self.percent_overlap = percent_overlap
			self.hop_size = hop_size
			self.starts = starts
			self.w = w
			self.xhat = xhat
\end{lstlisting}